package eu.ace_design.island.viewer

import java.io.{PrintWriter, File}

import eu.ace_design.island.geom.{Point, Mesh, VertexRegistry}
import eu.ace_design.island.map.IslandMap

/**
 * Create 3d mesh using the OBJ file format [http://en.wikipedia.org/wiki/Wavefront_.obj_file]
 */
class OBJViewer extends Viewer {

  override val extension: String = "obj"
  override val mimeType: String = "application/octet-stream"

  /**
   * Apply this transformation to a given map
   * @param m the map one wants to visualize
   * @return a File containing the associated representation
   */
  override def apply(m: IslandMap): File = {
    info("Building an OBJ file")
    val header =
      """####
         |## Island 3d model (OBJ compliant file)
         |## Automatically generated by the [OBJViewer] transformation process
         |####
      """.stripMargin
    val vertices: Seq[String] = buildVertices(m.mesh.vertices)
    val polygons: Seq[String] = buildPolygons(m.mesh)

    val result = initOutput
    val writer = new PrintWriter(result, "UTF8")
    writer.write(header)
    writer.write(s"\n\n####\n## Vertices registry\n####\n${vertices.mkString("\n")}")
    writer.write(s"\n\n####\n## Vertices registry\n####\n${polygons.mkString("\n")}")
    writer.close()
    info("done")
    result
  }

  /**
   * Build the vertices registry (sequence of vertex description in plain text)
   * A vertex is represented as "v $x $y $z"
   * @param vReg the vertex registry used to store the â‰  vertices
   * @return a sequence of vertex description
   */
  private def buildVertices(vReg: VertexRegistry): Seq[String] = {
    info("Building vertices index")
    // TODO support the z coordinates exploiting the properties!
    for(idx <- 0 until vReg.size)
      yield s"v ${vReg(idx).x} ${vReg(idx).y} 0.0"
  }

  /**
   * Transform the faces stored in the mesh into their OBJ representation
   * An OBJ face is a sequence of 3+ vertices references (starting at 1): "f v1 ... vN"
   * Specifying normals is optional (thus not done here)
   * @param mesh the mesh storing the faces, edges and vertices
   * @return a sequence of face description
   */
  private def buildPolygons(mesh: Mesh) = {
    import com.vividsolutions.jts.geom.{GeometryFactory, Coordinate}
    info("Building faces index")
    (0 until mesh.faces.size) map { idx =>
      val f = mesh.faces(idx)
      val involved = f.vertices(mesh.edges)
      // We need to build the convex hull of the polygon to obtain a convex representation of the face
      val coords = (involved map { mesh.vertices(_) } map { p => new Coordinate(p.x, p.y) }).toSeq
      val linear = coords :+ new Coordinate(coords(0).x, coords(0).y)
      val factory = new GeometryFactory()
      val convexCoords = factory.createPolygon(linear.toArray).convexHull.getCoordinates
      // Mapping back the convex polygon to vertices references (adding 1 as the numbering starts at 1)
      val indexes = convexCoords map { c => mesh.vertices(Point(c.x, c.y)).get + 1 }
      val processed = indexes.slice(1,indexes.size)  // removing the last one (the face is not a closed path)
      s"f ${processed.mkString(" ")}"
    }
  }


}
