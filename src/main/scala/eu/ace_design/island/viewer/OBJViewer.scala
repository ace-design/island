package eu.ace_design.island.viewer

import java.io.{PrintWriter, File}

import eu.ace_design.island.geom.{Point, Mesh, VertexRegistry}
import eu.ace_design.island.map.IslandMap


class OBJViewer extends Viewer {

  override val extension: String = "obj"
  override val mimeType: String = "text/plain"

  override def apply(m: IslandMap): File = {
    info("Building an OBJ file")
    val result = initOutput

    val header =
      """
         |####
         |## Island 3d model (OBJ compliant file)
         |## Automatically generated by the [OBJViewer] transformation process
         |####
      """.stripMargin
    val vertices: Seq[String] = buildVertices(m.mesh.vertices)
    val polygons: Seq[String] = buildPolygons(m.mesh)

    val writer = new PrintWriter(result)
    writer.write(header)
    writer.write(s"\n\n####\n## Vertices registry\n####\n${vertices.mkString("\n")}")
    writer.write(s"\n\n####\n## Vertices registry\n####\n${polygons.mkString("\n")}")
    writer.close()
    info("done")
    // TODO store face properties (e.g., biomes, type) as comments ?
    result
  }

  private def buildVertices(vReg: VertexRegistry): Seq[String] = {
    info("Building vertices index")
    for(idx <- 0 until vReg.size)
      yield s"v ${vReg(idx).x} ${vReg(idx).y} 0.0"
  }

  private def buildPolygons(mesh: Mesh) = {
    import com.vividsolutions.jts.geom.{GeometryFactory, Coordinate}
    info("Building faces index")
    (0 until mesh.faces.size) map { idx =>
      val f = mesh.faces(idx)
      val involved = f.vertices(mesh.edges)
      val coords = (involved map { mesh.vertices(_) } map { p => new Coordinate(p.x, p.y) }).toSeq
      val linear = coords :+ new Coordinate(coords(0).x, coords(0).y)
      val factory = new GeometryFactory()
      val convexCoords = factory.createPolygon(linear.toArray).convexHull.getCoordinates
      val indexes = convexCoords map { c => mesh.vertices(Point(c.x, c.y)).get + 1 }
      val processed = indexes.slice(1,indexes.size)
      s"f ${processed.mkString(" ")}"
    }
  }


}
