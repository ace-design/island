package eu.ace_design.island.map.resources

import eu.ace_design.island.map.resources.Conditions.Condition
import eu.ace_design.island.map.resources.ExistingBiomes.Biome
import eu.ace_design.island.map.resources.Soils.Soil

import scala.util.Random

/**
 * Soil can be divided into 3 categories: FERTILE (produce a lot), NORMAL and POOR (produce few resources).
 */
object Soils extends Enumeration {
  type Soil = Value
  val FERTILE, NORMAL, POOR = Value
}

/**
 * Exploitation conditions are divided into three categories: EASY (it is simple to harvest the resource), FAIR and
 * HARSH (it is difficult to exploit the resource).
 */
object Conditions extends Enumeration {
  type Condition = Value
  val EASY, FAIR, HARSH = Value
}

/**
 * This trait represents how the exploitation conditions are distributed on the island
 */
trait ExploitationDistribution {

  /**
   * Function used to assign a Soil and an exploitation Condition to a given biome
   * @param b the biome to work on
   * @param random a random generator, a default one is created if none given
   */
  def assign(b: ExistingBiomes.Biome, random: Random = new Random()): (Soils.Soil, Conditions.Condition) = {
    require(supported.contains(b), "Biome ["+b+"] is not supported")
    (soil(b, random), condition(b, random))
  }

  // The set of biome supported by this distribution
  val supported: Set[ExistingBiomes.Biome]

  /**
   * This function assigns to a given biome a soil type
   * @param b the biome to consider
   * @return
   */
  protected def soil(b: ExistingBiomes.Biome, random: Random): Soils.Soil

  /**
   * This function assigns to a given biome an exploitation condition type
   * @param b
   * @return
   */
  protected def condition(b: ExistingBiomes.Biome, random: Random): Conditions.Condition
}


/**
 * The standard distribution considers a 20/60/20 distribution of both soil types and exploitation conditions. It does
 * not take into account the biome in the assignment, purely random distribution.
 */
object StandardDistribution extends ExploitationDistribution {

  override val supported: Set[Biome] = ExistingBiomes.values

  override protected def condition(b: Biome, random: Random): Condition = random.nextDouble() match {
    case x if x < 0.2 => Conditions.EASY
    case x if x < 0.8 => Conditions.FAIR
    case _            => Conditions.HARSH
  }

  override protected def soil(b: Biome, random: Random): Soil = random.nextDouble() match {
    case x if x < 0.2 => Soils.FERTILE
    case x if x < 0.8 => Soils.NORMAL
    case _            => Soils.POOR
  }

}